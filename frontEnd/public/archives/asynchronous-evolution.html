<!DOCTYPE html>
        <html>
            <head>
                <meta charset="utf-8">
                <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
                <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
                <title>asynchronous-evolution</title>
                <link rel="stylesheet" href="../lib/semantic/dist/semantic.min.css">
                <link rel="stylesheet" href="../lib/highlight-github.css">
                <link rel="stylesheet" href="../lib/markdown.css">
                <style>
                    #toc_container {
                        position: fixed;
                        top: 10px;
                        width: 250px;
                        right: 10px;
                        word-break: break-word;
                    }
                </style>
            </head>
            <body class="ui main text container">
                <a href="https://maicss.com//Users/mac/Documents/code/js/blog2/archives/asynchronous-evolution.html#disqus_thread">count</a>
                <h1 id="javascript异步进化史">javascript异步进化史</h1><div><i class="tags icon"></i><div class="ui horizontal label">javascript</div> <div class="ui horizontal label">异步</div></div>
<div> <i class="calendar icon"></i>2017-03-16 13:34</div><p>什么是异步，为啥异步就不说了。</p>
<p>这里用nodejs的fs模块做演示。</p>
<p>要实现的目标：读一个文件夹下的文件。参数是一个路径。</p>
<p>这里假设既有文件目录结构是这样的：</p>
<div class="ui message"><pre><code class="lang-"><span class="hljs-comment">/*</span>
 aa
   -<span class="ruby"> test.js
</span> bb
   -<span class="ruby"> a.md =&gt; this is file1
</span>   -<span class="ruby"> b.md =&gt; this is file2
</span>   -<span class="ruby"> c.md =&gt; this is file3
</span>*/
</code></pre></div><p>以下代码都是在<code>test.js</code>里面写的，每次运行<code>node test.js</code>之后的结果都应该是<code>this is file1\nthis is file2\nthis is file3</code>。</p>
<div id="toc_container"><p>文章目录</p><ul class="ui list"><li class="item"><a href="#一代目-callback">一代目：callback</a><ul><li class="item"><a href="#同步">同步</a></li><li class="item"><a href="#callback">Callback</a></li></ul></li><li class="item"><a href="#二代目-promise">二代目：Promise</a><ul><li class="item"><a href="#原生promise手写">原生Promise手写</a></li><li class="item"><a href="#使用promise库bluebird">使用Promise库bluebird</a></li></ul></li><li class="item"><a href="#三代目-generator">三代目：Generator</a><ul><li class="item"><a href="#原生generator手写">原生Generator手写</a></li><li class="item"><a href="#使用generator库co">使用Generator库co</a></li></ul></li><li class="item"><a href="#终极火影-async-await">终极火影：async/await</a></li><li class="item"><a href="#参考">参考</a></li></ul></div><p>每个解决方案都有原生的方法示例和基于这个方案的比较流行的库的示例。</p>
<h2 id="一代目-callback">一代目：callback</h2><blockquote>
<p>为了更加完善的演示，下面的代码都带有错误处理，所以看起来很啰嗦，但是这样能显示出每个方法的异同。</p>
</blockquote>
<h3 id="同步">同步</h3><blockquote>
<p>这个是我们的终极目标，也就是写同步的代码，但是异步执行。</p>
</blockquote>
<div class="ui message"><pre><code class="lang-"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> path = <span class="hljs-string">'../bb'</span>;

<span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">let</span> files = fs.readdirSync(path);
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> file <span class="hljs-keyword">of</span> files) {
            <span class="hljs-built_in">console</span>.log(fs.readFileSync(path + file).toString())
        }
    } <span class="hljs-keyword">catch</span> (e) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'read file error: '</span>, e);
    }
} <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'read dir error: '</span>, e);
}
</code></pre></div><h3 id="callback">Callback</h3><div class="ui message"><pre><code class="lang-"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> path = <span class="hljs-string">'../bb'</span>;

fs.readdir(path, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e, files</span>) </span>{
    <span class="hljs-keyword">if</span> (e) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'read dir error: '</span>, e);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> file <span class="hljs-keyword">of</span> files) {
            fs.readFile(path + file, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e, content</span>) </span>{
                <span class="hljs-keyword">if</span> (e) {
                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'read file error: '</span>, e);
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-built_in">console</span>.log(content.toString())
                }
            })
        }
    }
});
</code></pre></div><p>这个方案的既有库的示例就是<code>jQuery</code>了。但是它是<code>Commonjs</code>规范下实现的产物，而ES6的<code>Promise</code>就是肯定了既定的<code>Commonjs</code>规范，所以<code>jQuery</code>的写法就是下面的原生<code>Promise</code>的写法。</p>
<h2 id="二代目-promise">二代目：Promise</h2><h3 id="原生promise手写">原生Promise手写</h3><div class="ui message"><pre><code class="lang-"><span class="hljs-comment">// 为了方便阅读，定义了两个函数。也可以尝试一个函数写下来……</span>
<span class="hljs-keyword">let</span> readDir = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">path</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
        fs.readdir(path, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e, files</span>) </span>{
            e ? reject(e) : resolve(files)
        })
    });
};

<span class="hljs-keyword">let</span> readFile = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">file</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
        fs.readFile(file, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e, content</span>) </span>{
            e ? reject(e) : resolve(content.toString())
        })
    });
};

readDir(path).then(<span class="hljs-function"><span class="hljs-params">files</span> =&gt;</span> {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> file <span class="hljs-keyword">of</span> files) {
        readFile(path + file).then(<span class="hljs-function"><span class="hljs-params">str</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(str), e =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'read file error: '</span>, e))
    }
}, e =&gt; {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'read dir error: '</span>, e)
});
</code></pre></div><h3 id="使用promise库bluebird">使用Promise库bluebird</h3><blockquote>
<p>这个比较厉害，建议就是替代自带的全局Promise</p>
</blockquote>
<div class="ui message"><pre><code class="lang-"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> path = <span class="hljs-string">'../bb/'</span>;

global.Promise = <span class="hljs-built_in">require</span>(<span class="hljs-string">'bluebird'</span>);

<span class="hljs-keyword">let</span> readFile = <span class="hljs-built_in">Promise</span>.promisify(fs.readFile);
<span class="hljs-keyword">let</span> readDir = <span class="hljs-built_in">Promise</span>.promisify(fs.readdir);

readDir(path).then(<span class="hljs-function"><span class="hljs-params">files</span> =&gt;</span> {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> file <span class="hljs-keyword">of</span> files) {
        readFile(path + file).then(<span class="hljs-function"><span class="hljs-params">content</span> =&gt;</span> {
            <span class="hljs-built_in">console</span>.log(content.toString())
        }).catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
            <span class="hljs-built_in">console</span>.log(e)
        });
    }
}).catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(e)
});
</code></pre></div><h2 id="三代目-generator">三代目：Generator</h2><h3 id="原生generator手写">原生Generator手写</h3><div class="ui message"><pre><code class="lang-"><span class="hljs-keyword">const</span> fs = <span class="hljs-keyword">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> path = <span class="hljs-string">'../bb/'</span>;


<span class="hljs-keyword">let</span> readDir = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(path)</span> </span>{
    fs.readdir(path, (e, files) =&gt; {
        <span class="hljs-keyword">if</span> (e) {
            handle.<span class="hljs-keyword">throw</span>(<span class="hljs-string">'read dir error: '</span>, e)
        } <span class="hljs-keyword">else</span> {
            handle.next(files)
        }
    })
};

<span class="hljs-keyword">let</span> readFile = <span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-params">(files)</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> file of files) {
        <span class="hljs-keyword">let</span> content = <span class="hljs-keyword">yield</span> fs.readFile(path + file, (e, content) =&gt; {
            <span class="hljs-keyword">if</span> (e) {
                handle.<span class="hljs-keyword">throw</span>(<span class="hljs-string">'read file error: '</span>, e)
            } <span class="hljs-keyword">else</span> {
                handle.next(content)
            }
        });
        l(content.toString());
    }
};

<span class="hljs-keyword">let</span> main = <span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">let</span> files = <span class="hljs-keyword">yield</span> readDir(path);
    <span class="hljs-keyword">yield</span> * readFile(files);
};

<span class="hljs-keyword">let</span> handle = main();
handle.next();
</code></pre></div><p>这里还可以看出，generator函数也有自己的错误处理方式，注意是generator的，不是javascript的那个命令式的<code>throw Error</code>。</p>
<p>按说，这样已经不错了，最后只需要用同步的方式yield两个表达式就行了。之后我们只需要些好函数之后，把最后两句包装起来，起个好听的名字，就完事了。</p>
<p>而且yield同步异步的都可以搞定。</p>
<p>但是这总有个尾巴next，而且内部的handle必须暴露在外面，而且里面的包装写起来比较麻烦。</p>
<p>于是有人说，我要一个能自动执行的generator，于是就有了一个自动执行的generator……</p>
<p>来来来，看看一步步写出个能自动执行的generator是啥样的：</p>
<blockquote>
<p>为了说明原理，只用一个异步函数作为示例
这里每块代码运行的结果都是 <code>[a.md, b.md, c.md]</code>，如果不是，不是你从copy错了就是我写错了。</p>
</blockquote>
<ul>
<li>1，先再写一遍上面readDir，下面的函数都是改造这个。</li>
</ul>
<div class="ui message"><pre><code class="lang-"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">let</span> path = <span class="hljs-string">'../bb/'</span>;

<span class="hljs-keyword">let</span> readDir = <span class="hljs-function"><span class="hljs-keyword">function</span> *(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">let</span> files = <span class="hljs-keyword">yield</span> fs.readdir(path, <span class="hljs-function">(<span class="hljs-params">e, files</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (e) {
            aa.throw(e)
        } <span class="hljs-keyword">else</span> {
            aa.next(files)
        }
    });

    <span class="hljs-built_in">console</span>.log(files)
};

<span class="hljs-keyword">let</span> aa = (readDir)();

aa.next();
</code></pre></div><ul>
<li>2，第一次改造。目标：能运行就行。</li>
</ul>
<div class="ui message"><pre><code class=""><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">let</span> path = <span class="hljs-string">'../bb/'</span>;

<span class="hljs-keyword">let</span> <span class="hljs-built_in">double</span> = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">gen</span>) </span>{
    <span class="hljs-keyword">let</span> iter = gen(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, data</span>) </span>{
        <span class="hljs-keyword">if</span> (err) {
            iter.throw(err);
        }
        <span class="hljs-keyword">return</span> iter.next(data);
    });
    iter.next();
}

<span class="hljs-keyword">let</span> gen = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params">cb</span>) </span>{
    <span class="hljs-keyword">let</span> files = <span class="hljs-keyword">yield</span> fs.readdir(path, cb);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> file <span class="hljs-keyword">of</span> files) {
        <span class="hljs-keyword">let</span> content = <span class="hljs-keyword">yield</span> fs.readFile(path + file, cb);
        <span class="hljs-built_in">console</span>.log(content.toString());
    }
}

<span class="hljs-built_in">double</span>(gen);
</code></pre></div><p>到这里，已经算是完成了。</p>
<p>但是那个cb实在是扎眼，作为使用者被要求传一个啥也不干的字符串很是恶心有木有。下面就再次改造把cb干掉。</p>
<ul>
<li>3，第二次改造。目标：只需要输入一个参数。</li>
</ul>
<div class="ui message"><pre><code class=""><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">let</span> path = <span class="hljs-string">'../bb/'</span>;

<span class="hljs-comment">// 这就是currying，先声明一个只需要一个参数的函数替代原来的函数</span>
<span class="hljs-keyword">let</span> readDir = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">path</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cb</span>) </span>{
        fs.readdir(path, cb)
    }
};

<span class="hljs-keyword">let</span> gen = <span class="hljs-function"><span class="hljs-keyword">function</span> *(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">let</span> files = <span class="hljs-keyword">yield</span> readDir(path);
    <span class="hljs-built_in">console</span>.log(files);
};

<span class="hljs-comment">// 你没看错，就是叫co。这个就是非Promise版本的co</span>
<span class="hljs-keyword">let</span> co = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">generator</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">let</span> gen = generator();

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">next</span>(<span class="hljs-params">err, result</span>) </span>{
            <span class="hljs-keyword">if</span> (err) {
                <span class="hljs-keyword">return</span> {<span class="hljs-attr">error</span>: err}
            }
            <span class="hljs-keyword">let</span> step = gen.next(result);
            <span class="hljs-keyword">if</span> (!step.done) {
                step.value(next);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> {<span class="hljs-attr">result</span>: step.value}
            }
        }

        next();
    }()
    <span class="hljs-comment">// 注意这里的自执行函数</span>
};

co(gen);
</code></pre></div><ul>
<li>4，终极改造。目标：弄出来一个Promise自动执行的版本</li>
</ul>
<div class="ui message"><pre><code class=""><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">let</span> path = <span class="hljs-string">'../bb/'</span>;

<span class="hljs-comment">// 但是到现在为止，我还是想不明白，上面的代码已经解决了同步代码解决异步的需求。为啥还要Promise</span>
<span class="hljs-keyword">let</span> readDir  = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">path</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> {
        fs.readdir(path, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e, data</span>) </span>{
            e ? rej(e) : res(data)
        });
    })
};

<span class="hljs-keyword">let</span> gen = <span class="hljs-function"><span class="hljs-keyword">function</span> * (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">let</span> files = <span class="hljs-keyword">yield</span> readDir(path);
    <span class="hljs-built_in">console</span>.log(files);
};

<span class="hljs-comment">// 这里就是co了。只是没有那么健全</span>
<span class="hljs-keyword">let</span> co = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">gen</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> {
        <span class="hljs-keyword">let</span> g = gen();
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">next</span>(<span class="hljs-params">result</span>) </span>{
            <span class="hljs-keyword">let</span> ret = g.next(result);
            <span class="hljs-keyword">if</span> (ret.done) {
                <span class="hljs-keyword">return</span> res(ret.result);
            }

            <span class="hljs-keyword">if</span> (!ret.value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'generator is not a Promise'</span>)
            }

            ret.value.then(next).catch(rej);
        }
        next()
    })
};

co(gen);
</code></pre></div><h3 id="使用generator库co">使用Generator库co</h3><div class="ui message"><pre><code class="lang-"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> co = <span class="hljs-built_in">require</span>(<span class="hljs-string">'co'</span>);

<span class="hljs-keyword">let</span> path = <span class="hljs-string">'../bb/'</span>;
<span class="hljs-keyword">let</span> readDir  = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">path</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> {
        fs.readdir(path, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e, data</span>) </span>{
            e ? rej(e) : res(data)
        });
    })
};

<span class="hljs-keyword">let</span> gen = <span class="hljs-function"><span class="hljs-keyword">function</span> * (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">let</span> files = <span class="hljs-keyword">yield</span> readDir(path);
    <span class="hljs-built_in">console</span>.log(files);
};

co(gen)
</code></pre></div><h2 id="终极火影-async-await">终极火影：async/await</h2><p>这里直接上代码，因为这个就是去掉*的generator。下面的代码很直观：</p>
<div class="ui message"><pre><code class="lang-">
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> co = <span class="hljs-built_in">require</span>(<span class="hljs-string">'co'</span>);
<span class="hljs-keyword">const</span> path = <span class="hljs-string">'../bb/'</span>;

<span class="hljs-keyword">let</span> readFile = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fileName</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
        fs.readFile(fileName, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, data</span>) </span>{
            <span class="hljs-keyword">if</span> (error) reject(error);
            resolve(data);
        });
    });
};

<span class="hljs-comment">// generator 版本</span>
<span class="hljs-keyword">let</span> gen = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">let</span> f1 = <span class="hljs-keyword">yield</span> readFile(path);
    <span class="hljs-built_in">console</span>.log(f1);
};

<span class="hljs-comment">// async/await 版本</span>
<span class="hljs-keyword">let</span> asyncReadFile = <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">let</span> f1 = <span class="hljs-keyword">await</span> readFile(path);
    <span class="hljs-built_in">console</span>.log(f1);
};

co(gen);
asyncReadFile();
</code></pre></div><p>基于这个实现的有很多，这个我就没研究过了。而且<code>bluebird</code>和<code>co</code>也都支持这个，也有单独的<code>async/await</code>库。</p>
<h2 id="参考">参考</h2><ul>
<li>阮一峰老师的<a href="http://es6.ruanyifeng.com/">ECMAScript 6 入门</a></li>
<li><a href="https://cnodejs.org/">cnode社区</a>的<a href="https://cnodejs.org/topic/53474cd19e21582e740117df">这篇文章</a></li>
<li><a href="https://github.com/tj/co">co库</a></li>
<li><a href="http://bluebirdjs.com/docs/api/">bluebird库</a></li>
</ul>

                <p><a href="../MD/asynchronous-evolution.md">查看本文Markdown版本</a></p>
                <div id="disqus_thread"></div>
                <script>
                
                /**
                *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
                *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
                
                var disqus_config = function () {
                this.page.url = 'https://maicss.com//Users/mac/Documents/code/js/blog2/archives/asynchronous-evolution.html';  // Replace PAGE_URL with your page's canonical URL variable
                this.page.identifier = 'asynchronous-evolution'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
                };
                
                (function() { // DON'T EDIT BELOW THIS LINE
                var d = document, s = d.createElement('script');
                s.src = '//https-www-maicss-com.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
                })();
                </script>
                <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                <script id="dsq-count-scr" src="//https-www-maicss-com.disqus.com/count.js" async></script>
            </body>
        </html>